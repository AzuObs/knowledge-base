= Protecting against Server Side Request Forgery (SSRF)
:slug: protecting-against-SSRF
:author: Irene Michlin
:neo4j-versions: 3.5, 4.0, 4.1, 4.2, 4.3, 4.4, 5.0
:tags: cypher, security
:category: security

== What is SSRF?

Server-side request forgery (SSRF) vulnerabilities let an attacker send crafted requests from the back-end server of a vulnerable web application. Criminals usually use SSRF attacks to target internal systems that are behind firewalls and are not accessible from the external network.

SSRF vulnerabilities occur when an attacker has full or partial control of the request sent by the backend application. 
SSRF is not limited to the HTTP protocol. 
Generally the input that the attacker controls is HTTP, but the backend request could use different protocols.

image::https://res.cloudinary.com/snyk/image/upload/v1638263093/snyk-learn/SSRF_Attack.svg[Attack illustration]

You can practice attacking a vulnerable application and learn about mitigations in https://learn.snyk.io/lessons/ssrf-server-side-request-forgery/javascript/[this interactive lesson from Snyk^].

== Why SSRF attacks are relevant to the Neo4j ecosystem

Neo4j is a graph database that is used to analyse data.
To enable the users easy onboarding of the existing data, we have to provide ways to load files (typically CSV files) locally or from the network via http.
With that functionality comes the ability of a potentially malicious user to manipulate the initial request - step one of SSRF.

== How to protect my environment

Given that SSRF is an OWASP Top 10 issue, OWASP has a https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html[comprehensive guide to prevention and mitigation^].


Given that users should be able to load the data from anywhere on the internet, this is falling into https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html#case-2-application-can-send-requests-to-any-external-ip-address-or-domain-name[Case 2^], which is more complex to defend against. 

But with an _defence in depth approach_, it is possible.

Neo4j does input validation as much as possible, which is your *application layer* defence. 
But to ensure _defence in depth_, you should do more on the *network layer*.  

The detection and prevention are highly specific to your infrastructure and network environment.

=== Running on AWS cloud

Use https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service/[IMDSv2^].

=== Running on Google cloud

Google has advisories for preventing access to https://cloud.google.com/compute/docs/metadata/querying-metadata[metadata^] and how to https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity[utilize workload identity to minimize access^].

=== Generic mitigation

Segment your network and configure your firewall to prevent access from Neo4j to the metadata subnet (if running on cloud) and any other sensitive backend subnets.
In most cases you want to prevent access to internal IP addresses originating from the backend service in general.

== Configuration option

TODO: document the unsupported.dbms.cypher_ip_blocklist here
