= Protecting against Server Side Request Forgery (SSRF)
:slug: protecting-against-SSRF
:author: Irene Michlin
:neo4j-versions: 3.5, 4.0, 4.1, 4.2, 4.3, 4.4, 5.0
:tags: cypher, security
:category: security

== What is SSRF?

Server-side request forgery (SSRF) vulnerabilities let an attacker send crafted requests from the back-end server of a vulnerable web application. Criminals usually use SSRF attacks to target internal systems that are behind firewalls and are not accessible from the external network.

SSRF vulnerabilities occur when an attacker has full or partial control of the request sent by the web application. SSRF is not limited to the HTTP protocol. Generally the input that the attacker controls is HTTP, but the backend request could use different protocols.

image::https://res.cloudinary.com/snyk/image/upload/v1638263093/snyk-learn/SSRF_Attack.svg[Attack illustration]

You can practice attacking a vulnerable application and learn about mitigations in this lesson:

 https://learn.snyk.io/lessons/ssrf-server-side-request-forgery/javascript/

== Why SSRF attacks are relevant to neo4j ecosystem

Neo4j is a graph database that is used to analyse data. To enable the users easy onboarding of the existing data, we have to provide ways to upload files (typically CSV files) locally or from the network.
With that functionality comes the ability of a potentially malicious user to manipulate the initial request - step one of SSRF.

== How to protect my environment

Given that SSRF is an OWASP Top 10 issue, OWASP has a comprehensive guide to prevention and mitigation:
https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html

Given that the users should be able to grab the data from anywhere on the internet, this is falling into (https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html#case-2-application-can-send-requests-to-any-external-ip-address-or-domain-name)[Case 2], which is more complex to defend. But with defence in depth approach, it is possible.

Neo4j does input validation as much as possible, which is your application layer defence. But to ensure defence in depth, you should do more on the network layer.  

The detection and prevention are highly specific to your infrastructure and network environment.

== Running on AWS cloud

Use (https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service/)[IMDSv2]

== Running on Google cloud

https://cloud.google.com/compute/docs/metadata/querying-metadata
https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity

== Generic mitigation

Segment your network and configure your firewall to prevent access from Neo4j to the metadata subnet (if running on cloud) and any other sensitive backend subnets. In most cases you want to prevent access to internal IP addresses in general.

== Configuration option

TODO: document the unsupported.dbms.cypher_ip_blocklist here
