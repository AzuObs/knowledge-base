= Migrating Explicit Lucene Indexes to Native Schema Indexes
:slug: Migrating-Explicit-Lucene-Indexes-to-Native-Schema-Indexes
:author: Ali Maddahian
:category: operations
:tags: lucene, index, legacy, explicit, capacity, schema, full-text
:neo4j-versions: 1.x,2.x,3.x,4.x

Given that there are still some customers on older releases still utilizing legacy/explicit indexes, we will point out a few pointers here on how to convert these indexes to native schema indexes when upgrading to Neo4j version 4.x, as legacy/explicit indexes have been deprecated as of 3.5.x, and totally removed from the 4.x version.
 
As to the background, Legacy/explicit indexes were the only type of indexes available prior to Neo4j 3.2(release date 2017).   These early version indexes which were implemented via Lucene under the cover resulted in significant write performance, and thus the need to replace them with the native schema indexex available in 3.3+ releases.   

Aside from the performance perspective and equally important, explicit indexes also have to be explicitly/manually kept-up-to date when adding/removing/updating nodes/relationships/properties by way of the Java API (and/or stored procedures starting with 3.3.x), hence why they are called an explicit index.    

In contrast, native indexes are maintained automatically, thus eliminating the need for any such manual steps and/or extra code to keep them current.

From an implementation perspective, these legacy indexes do not list much of schema details and besides the original author's chosen naming convention at the time of the index creation, there is not a whole lot of usable clue to help with implementing an automated process for migrating these indexes to Neo4j’s native schema indexes in a scripted manner.

Thus any index migration would have to be done on an index by index basis and might involve some level of guessing.   This means you having to look at the API code and assess which node or relationship properties are being indexes, and accordingly implement a complementing schema index on those properties and/or look at the cypher query and come up with supporting indexes to optimize its execution.

Overall at a high level, here is the recommended approach:

1) Get a listing of all your indexes on you existing version

*  Example:   in 3.x you can use **"call db.index.explicit.list();"** which will show the index name as well as its type, which can be either “exact” or “full-text”, as well as if it is a node or relationship index, which will help you to determine what type of schema index to construct. 
 
2) Next look at your cypher and/or Java API code and Convert them accordingly to 4.x+ format, 

3) sort of guess what equivalent schema index you would need to support and optimize the execution of the associated/converted queries from step 2. 
 
* inspect all cypher queries for what they actually write to that index and derive either a create index (for integer, strings, dates, geospatial, etc) and/or call db.index.fulltext.createIndexForNodes (FTS) statements.
 
* Inspect all reads to that index and adopt the statements to use the new index (this would mean to enable query logging to capture generated cypher queries and its performance attributes such as execution time vs io vs memory, vs cpu to flag longest running queries to troubleshoot individually one at a time - and more than likely your query patterns are similar to each other, hence, once one query is fixed, it will similarly help other similar queries.).
 
4) Once finished with all explicit indexes shut down the db and get rid of index subfolder


As a side note, 3.3, also offered explicit index implementations via stored-procedures, to make them easier to implement outside of API, however, these had to be maintained manually up-to-date.  These set of procedures were also deprecated as of 3.5.x, and 4.x replaced with new set of procedures (again to be used for FTS usecases) as documented here:  https://neo4j.com/docs/cypher-manual/current/administration/indexes-for-full-text-search/
 
For a full list of deprecated features per each version please visit the following link:  https://neo4j.com/docs/cypher-manual/current/deprecations-additions-removals-compatibility/

